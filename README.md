# Introduction to programming and RStudio

## Overview of RStudio

RStudio is an interpretive coding language, which means that it takes human inputted letters, words, numbers, etc. in a specific form of syntax to allows users to "talk" to the computer and ask it to perform a wide variety of computations (without having to speak like a computer thankfully). There are generally two ways to communicate with the computer when we're coding: through the command line, or *console* in the case of RStudio, where we provide individual commands one at a time, or using a coding script where we write many commands to a document that run in sequence. Scripting is almost universally favored over writing individual commands to the console for several reasons: it enables the user to write much more complex analyses (many elements of advanced coding require many lines of commands), it saves a lot of time (you can save a script file and have RStudio automatically re-run all of the commands in the file any time), and it aids the reproducibility of your code.

This tutorial will first and foremost provide you with a simple R script to demonstrate how to leverage a programming language like R to analyze data with much greater efficiency and complexity than can be done by hand. We'll go over some key elements of computer syntax and structure, as well as describe how to create dynamic variables to store pieces of information. Through the course of the script you will be able to see how simple numerical computations can be performed quickly and efficiently by the computer, how you can leverage a huge repository of pre-built functions to perform more advanced computations, and how to start to construct more complex logic-based code chunks. This guide is meant to be followed along as you run the commands in the `intro-script.r` file in sequence.

## Getting started with programming in R

The classic first thing to do in any programming language is to `print` the phrase *"Hello World"* to the console. This is a great first example of how you can provide input to the computer and get that input returned as output through the computer console. In this case the *output* is simply displaying the same information back to you on the screen, but we'll see that you can do a whole lot more than that! As you'll see throughout this tutorial, the computer does not actually save anything when you run something like a `print` statement so it has no record of that input being provided to it. If we wanted to save this string *"Hello World"* for all posterity, or until our RStudio session is closed down, we can use the variable assignment syntax `<-` or `=` to tell R to save the command `print("Hello World")` to a *variable* that we get to name (e.g., `statement`).

With *"Hello World"* comfortably under our belt, we can move to doing some simple arithmetic with the help of our programming language. Again using the `print` command to send the output to the console, you can ask R to add, subtract, multipy, and divide numbers explicitly (e.g., `2+2`). This is great, but often the numbers we want to perform arithmetic change a lot, and I'd hate to have to change all those 2's one by one! To avoid this calamity, we can next save the numbers we want to do arithmetic on to variables to reduce the amount of changes we might have to make. If you now set a variable `a` to the number 2, RStudio will *remember* that anytime you reference `a` going forward that what you really mean is the number 2 (NOTE: single letter variable names are a poor idea in general, you might forget what `a` is a lot faster than you'll forget what `fixed.number` is). We can of course still combine `a` with an explicitly defined number to repeat our arithmetic, or we can set both numbers to variable by adding a variable `b` to the mix. Now if you need to use new numbers for these computations you just have to change `a` and `b` one time each!

Before we continue on to some good rules of thumb for initializing scripts, one important structural element of computer coding that's worth mentioning is the use of data *types*. In order to properly function, R has to bin any input you give it into one of a set of discrete kinds of data. For the arithmetic above for example, R treats these numbers as either *integers* (whole numbers) or *doubles* (rational numbers, like 1.33). Our favorite *"Hello World"* phrase is what R calls a *string*. Some other *types* we'll discuss later on are *vectors* and *dataframes*, but there are several others as well.

## Basics setup components for a typical R script

Now that we have the basics operations down, and an idea of how to visualize our output to the console, let's discuss some practical aspects of writing scripts in general. Typically, we always want to begin any RStudio script by doing two things: setting the working directory, and loading the packages that we plan on using. Setting the working directory is our way of letting RStudio know where its homebase on our computer. We want to do this so that RStudio knows how to look around and find any files that we might want it to access in the course of our analyses. We can easily figure out where we currently are with the `getwd()` command and we can just as easily set a new location with the `setwd()` command. Before you start messing around with rerooting your RStudio in a new directory, I always recommend saving you current directory to a variable 

```
curr_directory <- getwd()
``` 

just in case you can't find your way back (NOTE: whether you put *spaces* around the `<-` variable assignment syntax is just a stylistic choice). One particular place that we can send RStudio to using a special character `~` is the root/home directory of our computer by running `setwd("~")`. Generally, that directory's name isn't actually "~" but it is considered the origin of all the files on your system (e.g., on Mac this directory is called "/Users/\<your-first-name\>").

As an interpretive language, RStudio also has a huge universe of pre-built functions that allow us to perform much more complicated commands in a simpler and more efficient way. To access these functions, RStudio uses *packages*. A good rule of thumb is that if there's something specific you want to do that base R can't, there's probably a package out there for it already (and can usually be found with a Google search). Once you have a package in mind it can be easily installed using the `install.packages()` command. For this example script we will install two packages, *datasets* and *tidyverse*. In order to actually have access to a package that you've installed you need to load that package using the `library()` function. The package *datasets* is pretty self-explanatory as it gives us access to several neatly constructed datasets that you can load and mess around with. The package *tidyverse* is an extremely powerful package for manipulating a specific variable *type* in R that is very common in data analysis, a *dataframe*.

## Constructing vectors and performing more advanced computations

A very common and fundamental type of data in programming is a *vector* which is typically a list of several elements with the same data *type*. For example, we'll create a *vector* that consists of 8 elements (we might say this vector is of length 8), each of which is an integer value. We can of course use our favorite `print()` command to view this in the console! Now, however, we can being to use some base R pre-built functions to ask more complex questions about our data. For instance, we can now measure things such as the total *sum* of the elements in our vector as well as what the *mean* of our values is using the functions `sum()` and `mean()`. Another important thing we can do with vectors is *index* them. Indexing a vector allows us to tell the computer to show us specific elements, or to use only those specific elements when running a subsequent command on the values stored in that vector variable. Helpfully, R counts just like humans (starting at 1) so indexing is very intuitive!

## Learning how to view and manipulate dataframes

Now that we've played around with vectors a little bit, let's now consider the more complex example of *dataframes*. In simple terms, *dataframes* are typically just a combination of many *vectors* of the same length. This is what leads to the two-dimensional architecture of a dataframe. We can load a pre-built dataframe that is very commonly used in RStudio called the *iris* dataset to demonstrate the structure of a dataframe. After loading it we can run our handy `print()` function again and see that the console will display 5 columns of data (each of which is a vector). Dataframes have their own unique syntax as well, in particular we often want to be able to index whole vectors from our dataframe. To do this we use the special character `$` to tell R to look at whole vectors from a dataframe. For example, for a dataframe titled `test.data` with a column named `numeric.data` we can tell R to show us the whole vector by running the command `test.data$numeric.data`. As you can see, having meaningful column names can be very useful and these names are themselves a variable that we can modify by calling the `colnames()` function. 

Just like you can with single value variables and vectors, you can perform arithmetic directly on the columns of a dataframe using this `$` syntax to select them. And like with multiple element vectors as well you can use functions like `sum()` and `mean()` to ask more complex questions of our data! Another special syntax that we get access to by loading the *tidyverse* package is pipes, denoted by the special clause `%>%`. Pipes are an extremely useful tool when dealing with dataframes that allow us to do multiple commands in sequence, passing the output from the previous command to the next command. One classic example is data filtration. Oftentimes, we only want to look at parts of our data that meet a certain filter, and we can accomplish this with pipes by passing the dataframe to the `filter` command. The `filter` command allows us to directly compare the values of a dataframe column to a certain condition using the name for that column (e.g., "Sepal.Width"). These filters can take many forms but classic examples are numeric filters, or string filters that isolate only the elements of a dataframe column that belong to the same group, for example. These filtered slices can also be saved as variables for future work.

## Basic input/output, saving and loading data, and simple plots

In the course of your programming and data analysis, you'll often have data files that you want to save so you can use them in other scripts, and files you need to load as a prerequisite to running other commands. There are many functions to do this type of input/output work, and which one you choose often depends most on the format of your data (e.g., comma-separated versus tab-separated). For saving data you've just generated, like one of our dataframe slices, you can use functions like `write.csv()` or `write.table()` and typically you need to provide the variable of the data you want to save along with a name for the file. It's generally a good idea to put the correct file extension at the end of your filename (like ".csv" or ".tsv"). In the same way that you wrote a file to your computer, you can read that file back into your RStudio environment to make the stored variable accessible to you using functions like `read.table()` or `read.csv()`.

If you want to save your entire workspace (console, environment, etc.) so you can pick up where you left off, you can also save the R workspace itself as a `.RData` file (which is just a special R-specific file type). You can use `save()` and `load()` in a variety of ways. If you're unsure on how exactly to use a command like `save()` for example, RStudio has really useful built-in help documentation that can be accessed by the special character `?`. For example to look at documentation on `save()` or `read.csv()` you can just type `?save()` or `?read.csv()` into your console and run the command (NOTE: the parentheses are optional for this command).

Another key use of programming is the ability to create plots of your data to look at trends, analyze your data, etc. Plots will be discussed in much greater detail in a later lecture, but we provide a simple example of a plot here. The `plot()` function can take a lot of inputs, and you often won't use many or all of them. In this example, you can plot two columns of the data slice from the iris dataframe by calling them with the `$` character. To make your plot more easy to understand, you can label many aspects of it incluing the title (`main`) as well as the x and y lables (`xlab` and `ylab`). 


## Introduction to computer logic and command loops

The last thing this tutorial will cover is computer logic and command loops, which often use a lot of computer logic. Two common command loops are `for` loops and `if` loops. A `for` loop will typically run through a list of elements, defined in the parentheses, and perform an operation or many operations on each element in the list independently. This type of loop may or may not use computer logic, however many loops do rely on this type of logic to tell the computer when to perform the operations specified within the loop. *Logic* is a computer's way of delineating statements that are **TRUE** or **FALSE** and is a key way of communicating between us and the computer. You can always test the logical output of any statement you create (where applicable). For example if you type `1==1` into the console you will return to **TRUE** because thankfully it turns out that 1 is in fact 1. Logic is a key component of the other type of very common loops, the `if` loop. An `if` loop checks a logical condition, and based on the output of that logical check, performs a specific set of commands. You can also use the `else` qualifier as part of an `if` loop to tell the computer what to do in the case that the logical check returns the **FALSE** condition. As your programming and data analysis gets more complicated, you'll even find yourself combining these loop types into what we call *nested loops*!